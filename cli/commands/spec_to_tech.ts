import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import * as p from "@clack/prompts";
import pc from "picocolors";

type SpecToTechOptions = {
  runId: string;
  taskId: string;
  workspace?: string;
};

function formatKstIso(date: Date): string {
  const kst = new Date(date.getTime() + 9 * 60 * 60 * 1000);
  return kst.toISOString().replace("Z", "+09:00");
}

const TECH_TEMPLATE = `# TECH.md — Technical Specification

> Auto-generated by \`oh-my-ag spec:to-tech\` from SPEC.md

## 1. Goal Summary

\${GOAL_SUMMARY}

## 2. Scope

### In-Scope

\${SCOPE_IN}

### Out-of-Scope

\${SCOPE_OUT}

## 3. Architecture

\${ARCHITECTURE}

## 4. Risks & Approvals

| Risk | Level | Mitigation |
|------|-------|------------|
| \${RISK_ROW} | | |

- **HITL Required**: \${HITL_REQUIRED}
- **Approvals**: See \`.serena/evidence/<run_id>/<task_id>/approvals.json\`

## 5. Verification Plan

\${VERIFICATION_PLAN}

## 6. Rollout Plan

\${ROLLOUT_PLAN}
`;

function extractSection(specContent: string, heading: string): string {
  const regex = new RegExp(
    `^#{1,3}\\s*${heading}[^\\n]*\\n([\\s\\S]*?)(?=^#{1,3}\\s|$)`,
    "mi",
  );
  const match = specContent.match(regex);
  return match?.[1]?.trim() || `(Not found in SPEC — fill manually)`;
}

function buildTechMd(specContent: string): string {
  let tech = TECH_TEMPLATE;

  const goalSummary = extractSection(specContent, "(?:Goal|Summary|Overview|목표)");
  const scopeIn = extractSection(specContent, "(?:In.Scope|Scope|범위)");
  const scopeOut = extractSection(specContent, "(?:Out.of.Scope|제외)");
  const architecture = extractSection(specContent, "(?:Architecture|아키텍처|설계)");
  const risks = extractSection(specContent, "(?:Risk|위험|Approval)");
  const verification = extractSection(specContent, "(?:Verification|검증|Test)");
  const rollout = extractSection(specContent, "(?:Rollout|배포|Deploy)");

  tech = tech.replace("${GOAL_SUMMARY}", goalSummary);
  tech = tech.replace("${SCOPE_IN}", scopeIn);
  tech = tech.replace("${SCOPE_OUT}", scopeOut);
  tech = tech.replace("${ARCHITECTURE}", architecture);
  tech = tech.replace("${RISK_ROW}", risks.split("\n")[0] || "(TBD)");
  tech = tech.replace("${HITL_REQUIRED}", "true");
  tech = tech.replace("${VERIFICATION_PLAN}", verification);
  tech = tech.replace("${ROLLOUT_PLAN}", rollout);

  return tech;
}

export async function specToTech(
  specPath: string,
  options: SpecToTechOptions,
): Promise<void> {
  const { runId, taskId } = options;
  const workspace = options.workspace || process.cwd();

  // --- Validate inputs ---
  if (!specPath || !runId || !taskId) {
    p.log.error("spec-path, --run-id, and --task-id are all required");
    process.exit(2);
  }

  const resolvedSpec = join(workspace, specPath);
  if (!existsSync(resolvedSpec)) {
    p.log.error(`SPEC file not found: ${resolvedSpec}`);
    process.exit(2);
  }

  const specContent = readFileSync(resolvedSpec, "utf-8");

  // --- Generate TECH.md ---
  const techContent = buildTechMd(specContent);
  const techPath = join(workspace, "docs", "TECH.md");
  mkdirSync(join(workspace, "docs"), { recursive: true });
  writeFileSync(techPath, techContent, "utf-8");

  // --- Create evidence pack ---
  const timestampKst = formatKstIso(new Date());
  const evidenceDir = join(workspace, ".serena", "evidence", runId, taskId);
  mkdirSync(evidenceDir, { recursive: true });

  const evidenceFiles: { name: string; content: string }[] = [
    {
      name: "evidence_pack.yaml",
      content: [
        `run_id: "${runId}"`,
        `task_id: "${taskId}"`,
        `timestamp_kst: "${timestampKst}"`,
        "",
        "artifacts:",
        "  paths:",
        "    - docs/TECH.md",
        "inputs:",
        `  source_refs:`,
        `    - "${specPath}"`,
        "  file_hashes: []",
        "  config_versions: []",
        "assumptions: []",
        "decisions:",
        "  - Generated TECH.md from SPEC via spec:to-tech",
        "tests: []",
        "approvals:",
        "  hitl_required: false",
        "",
      ].join("\n"),
    },
    {
      name: "verification_report.md",
      content: [
        "# Verification Report",
        `- Source: ${specPath}`,
        "- Output: docs/TECH.md",
        "- Status: PENDING",
        `- Generated: ${timestampKst}`,
        "",
      ].join("\n"),
    },
    {
      name: "execution_log.txt",
      content: [
        `[${timestampKst}] spec:to-tech started`,
        `[${timestampKst}] Read SPEC from ${specPath}`,
        `[${timestampKst}] Generated docs/TECH.md`,
        `[${timestampKst}] Created evidence pack at .serena/evidence/${runId}/${taskId}/`,
        "",
      ].join("\n"),
    },
    {
      name: "approvals.json",
      content:
        JSON.stringify(
          {
            schema_version: "1",
            run_id: runId,
            task_id: taskId,
            status: "PENDING",
            requested_by: "agent",
            requested_at: timestampKst,
            decision: { by: null, at: null, reason: null },
            scope: {
              risk_level: "LOW",
              actions: ["spec-to-tech"],
              targets: [`.serena/evidence/${runId}/${taskId}/`],
            },
          },
          null,
          2,
        ) + "\n",
    },
  ];

  for (const file of evidenceFiles) {
    writeFileSync(join(evidenceDir, file.name), file.content, "utf-8");
  }

  // --- Write result-pm.md ---
  const memDir = join(workspace, ".serena", "memories");
  mkdirSync(memDir, { recursive: true });
  const resultPmPath = join(memDir, "result-pm.md");
  writeFileSync(
    resultPmPath,
    `EVIDENCE_PATH: .serena/evidence/${runId}/${taskId}/\n`,
    "utf-8",
  );

  // --- Output ---
  p.log.success(`TECH.md created: ${pc.cyan(techPath)}`);
  p.log.success(`Evidence pack: ${pc.cyan(evidenceDir)}`);
  p.log.success(`Result memory: ${pc.cyan(resultPmPath)}`);
}
